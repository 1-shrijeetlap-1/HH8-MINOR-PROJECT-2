
// Source code is decompiled from a .class file using FernFlower decompiler (from Intellij IDEA).
import java.io.File;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.OpenOption;
import java.security.SecureRandom;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.SecretKeySpec;

public class SecurityUtil {
   private static final String ALGORITHM = "AES/GCM/NoPadding";
   private static final int TAG_LENGTH_BIT = 128;
   private static final int IV_LENGTH_BYTE = 12;
   private static final int SALT_LENGTH_BYTE = 16;
   private static final int ITERATION_COUNT = 600000;
   private static final int KEY_LENGTH_BIT = 256;

   public SecurityUtil() {
   }

   public static void save(String var0, char[] var1, File var2) throws Exception {
      SecureRandom var3 = new SecureRandom();
      byte[] var4 = new byte[16];
      var3.nextBytes(var4);
      byte[] var5 = new byte[12];
      var3.nextBytes(var5);
      SecretKey var6 = deriveKey(var1, var4);
      Cipher var7 = Cipher.getInstance("AES/GCM/NoPadding");
      GCMParameterSpec var8 = new GCMParameterSpec(128, var5);
      var7.init(1, var6, var8);
      byte[] var9 = var7.doFinal(var0.getBytes(StandardCharsets.UTF_8));
      ByteBuffer var10 = ByteBuffer.allocate(var4.length + var5.length + var9.length);
      var10.put(var4);
      var10.put(var5);
      var10.put(var9);
      Files.write(var2.toPath(), var10.array(), new OpenOption[0]);
   }

   public static String load(char[] var0, File var1) throws Exception {
      if (!var1.exists()) {
         throw new Exception("No save file found.");
      } else {
         byte[] var2 = Files.readAllBytes(var1.toPath());
         ByteBuffer var3 = ByteBuffer.wrap(var2);
         if (var3.remaining() < 28) {
            throw new Exception("File corrupted");
         } else {
            byte[] var4 = new byte[16];
            var3.get(var4);
            byte[] var5 = new byte[12];
            var3.get(var5);
            byte[] var6 = new byte[var3.remaining()];
            var3.get(var6);
            SecretKey var7 = deriveKey(var0, var4);
            Cipher var8 = Cipher.getInstance("AES/GCM/NoPadding");
            GCMParameterSpec var9 = new GCMParameterSpec(128, var5);
            var8.init(2, var7, var9);
            byte[] var10 = var8.doFinal(var6);
            return new String(var10, StandardCharsets.UTF_8);
         }
      }
   }

   private static SecretKey deriveKey(char[] var0, byte[] var1) throws Exception {
      PBEKeySpec var2 = new PBEKeySpec(var0, var1, 600000, 256);

      SecretKeySpec var5;
      try {
         SecretKeyFactory var3 = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256");
         SecretKey var4 = var3.generateSecret(var2);
         var5 = new SecretKeySpec(var4.getEncoded(), "AES");
      } finally {
         var2.clearPassword();
      }

      return var5;
   }

   public static String checkStrength(String var0) {
      if (var0 != null && var0.length() >= 8) {
         boolean var1 = var0.matches(".*[A-Z].*");
         boolean var2 = var0.matches(".*[a-z].*");
         boolean var3 = var0.matches(".*[0-9].*");
         boolean var4 = var0.matches(".*[^a-zA-Z0-9].*");
         int var5 = 0;
         if (var1) {
            ++var5;
         }

         if (var2) {
            ++var5;
         }

         if (var3) {
            ++var5;
         }

         if (var4) {
            ++var5;
         }

         if (var5 < 2) {
            return "Weak";
         } else {
            return var5 != 2 && var5 != 3 ? "Strong" : "Medium";
         }
      } else {
         return "Weak (Too short)";
      }
   }
}
